import java.util.Iterator;
import java.util.Map;

/**
 * This class represents a UserAccounts file, in memory. It
 * inherits read and write methods from Data and overrides
 * the encode and decode methods. It has methods to add or
 * delete a User and add or remove credit from a users
 * account. The methods provide validation in which errors are
 * reported to caller and logged.
 */
public class Accounts extends Data {

	/**
	 * a map with key, username, and value, User, that represents
	 * the UserAccounts file
	 */
	private Map<String, User> users;
	/**
	 * an iterator of the users map
	 */
	private Iterator<User> userIterator;

	/**
	 * Constructor method for Accounts class. It calls the super class
	 * Data's constructor and builds the user accounts representation in
	 * memory.
	 * @param readFilename a string representing the path of the existing UserAccounts
	 * file
	 * @param writeFilename a string representing the path to the new UserAccounts file
	 * to be written
	 */
	public Accounts(String readFilename, String writeFilename) {
        super(readFilename, writeFilename);
        // TODO - implement Accounts.Accounts
		throw new UnsupportedOperationException();
	}

	/**
	 * This method is responsible for creating a new user in memory. It
	 * validates name is not already in the system, type is a valid type,
	 * and credit does not exceed maximum or minimum. Any errors are reported back to caller.
	 * @param name a string that represents the name of User
	 * @param type a char array that represents the User's type
	 * @param credit a double that represents a User's available credit.
	 * @return 0 on success, 1 on failure, 2 on UserExistsError, 3 on on
	 * UserTypeError, 4 on UserCreditError
	 */
	public int newUser(String name, char[] type, double credit) {
		// TODO - implement Accounts.newUser
		throw new UnsupportedOperationException();
	}

	/**
	 * This method is responsible for validating and deleting a user account
	 * from memory. It validates that name exists on the system and reports
	 * errors to caller. If all business constraints are met it deletes the
	 * user from memory.
	 * @param name a string that represents the name of User
	 * @return 0 on success, 1 on failure, 2 on UserDoesNotExistError
	 */
	public int deleteUser(String name) {
		// TODO - implement Accounts.deleteUser
		throw new UnsupportedOperationException();
	}

	/**
	 * This method is responsible for retrieving a User account from the map
	 * of accounts in the system. If user does not exist Null is returned.
	 * @param name a string that represents the name of User
	 * @return an objects that represents a User account on success, Null on failure
	 */
	public User getUser(String name) {
		// TODO - implement Accounts.getUser
		throw new UnsupportedOperationException();
	}

	/**
	 * This method is overrides Data's decode method by parsing a line of
	 * text from a file and using the values to create a user in memory. It
	 * is also responsible for validating the parsed values to ensure
	 * business constraints. An error generated by and invalid value
	 * will return a fatal error to the calling function.
	 * @param line
	 * @return 0 on success, 1 on failure, 2 on fatal error
	 */
	public int decode(String line) {
		// TODO - implement Accounts.decode
		throw new UnsupportedOperationException();
	}

	/**
	 * This method overrides the encode method in data. The method get the
	 * next user from the userIterator and converts its data to a formatted
	 * string. name is 15 char with trailing spaces, type is 2 char, credit
	 * is 9 digits with or without decimal and leading 0's. All fields have
	 * a blank space between them. The formatted line is returned to be
	 * written to file. If end of data set is reached a EOF is sent
	 * signaling calling function to finish write.
	 */
	public String encode() {
		// TODO - implement Accounts.encode
		throw new UnsupportedOperationException();
	}

}